// 题目的需求是:给定一个字符串,找到其最多可以被分成多少个一样的字符串,比如abcabcabcabc,可以
// 被分成2个abcabc，也可以被分成4个abc,所以对于字符串abcabcabcabc来说,答案就是4.
// 虽然评论里很多人用的是kmp算法,但这里的实现不算kmp,差不多贪心+ad hoc的感觉.
// 算法:
//  1.假设满足条件的字符串s1的长度为k,从字符串头开始每隔k个长度进行一次比较
//  2.如果相同,则s1和正在比较的字符串s的指针都指向下一个字符
//  3.如果不同,则不存在满足条件的长度为k的字符串,重点就在这儿,如果只是简单的
//  把k的长度+1,可以求出解,但会超时.这里就和kmp的失败函数一样,需要计数k增加的
//  长度.这里k的修正方法是:当前匹配到的字符串的位置j - 模式串的匹配位置i + 1.
//  这样就能跳过,之前已经匹配成功的所有字符串,如果k的长度为10,之前已经成功匹配
//  了10个字符串,则可以跳过100个位置,极大的提高了效率.
#include <stdio.h>
#include <string.h>

#define MAX 100100
char str[MAX];

// 快速io,且顺便求出字符串长度,避免了调用strlen的开销
int fastio()
{
    int i = 0;
    char c;
    while(1)
    {
        c = getchar();
        if(c < '!')
            break;

        str[i] = c;
        ++i;
    }

    str[i] = '\0';

    return i;
}

int main(void)
{
    while(1)
    {
        int len = fastio();
        if(str[0] == '*') 
            break;

        int k = 1;      // 模式串的长度
        int i = 0;      // 模式串的指针
        int j = i + k;  // 匹配串的指针

        while(j < len)
        {
            if(str[i] == str[j])
            {
                ++i;
                ++j;

                // 成功匹配了一个字符串,模式串指针重置,
                // 准备匹配下一个字符串
                if(i == k)
                    i = 0;
            }
            else
            {
                // 匹配失败,修正k的值,重置模式串指针,
                // 匹配串的指针指向一个开始匹配的位置
                k = j - i + 1;
                i = 0;
                j = k;
            }
        }

        // 字符串匹配完后,如果模式串还有剩余,则有不完整的匹配
        // 比如ababa,模式串是ab,最后匹配了个a,剩余个b
        if(i != 0)
            k = len;

        printf("%d\n", len / k);
    }

    return 0;
}
